//! Handle the callback from the ID provider
//! GET /sso/authorize
use std::collections::HashMap;

use authifier::config::Claim;
use authifier::models::IdProvider;
use authifier::{Authifier, Error, Result};
use rocket::http::{Cookie, CookieJar};
use rocket::{serde::json::Json, State};

#[derive(Serialize, Deserialize, JsonSchema, FromForm)]
pub struct DataCallback {
    /// The authorization code generated by the authorization server.
    pub code: Option<String>,
    /// The access token to access the requested scope.
    pub access_token: Option<String>,
    /// ID Token value associated with the authenticated session.
    pub id_token: Option<String>,
}

#[derive(Serialize, Deserialize, JsonSchema)]
pub struct ResponseCallback {
    login_token: String,
    redirect_uri: String,
}

/// # Handle the callback from the ID provider
///
/// Handle the callback from the ID provider.
#[openapi(tag = "SSO")]
#[get("/callback?<data..>")]
pub async fn callback(
    authifier: &State<Authifier>,
    data: DataCallback,
    cookies: &CookieJar<'_>,
) -> Result<Json<ResponseCallback>> {
    let secret = authifier.database.find_secret().await?;
    let cookie = cookies.get("callback-id").map(Cookie::value);

    let id: String = match cookie.map(|c| secret.validate_claims(c)).transpose() {
        Ok(value) => value.ok_or(Error::MissingCallback)?,
        Err(_) => {
            return Err(Error::InvalidCallback);
        }
    };

    let callback = authifier.database.find_callback(&id).await?;
    {
        authifier.database.delete_callback(&id).await?;
    }

    let id_provider = match authifier.config.sso.get(&*callback.idp_id).cloned() {
        Some(config) => IdProvider::try_from(config).map_err(|_| Error::InvalidIdpConfig)?,
        None => return Err(Error::InvalidIdpId),
    };

    let Some(code) = data.code.as_deref() else {
        return Err(Error::MissingAuthCode);
    };

    let (response, id_token) = id_provider
        .exchange_authorization_code(authifier, code, &id)
        .await?;

    let mut claims = HashMap::with_capacity(id_provider.claims.len());

    if let Some(id_token) = id_token {
        let values = id_provider.claims.iter().filter_map(|(claim, key)| {
            let value = id_token.get(key).cloned()?;

            Some((claim.to_owned(), value))
        });

        claims.extend(values);
    }

    if let Some(userinfo) = id_provider
        .fetch_userinfo(authifier, &response.access_token)
        .await?
    {
        let values = id_provider.claims.iter().filter_map(|(claim, key)| {
            let value = userinfo.get(key).cloned()?;

            Some((claim.to_owned(), value))
        });

        claims.extend(values);
    }

    let Some(_sub) = claims.get(&Claim::Id) else {
        return Err(Error::InvalidIdClaim);
    };

    todo!()
}
