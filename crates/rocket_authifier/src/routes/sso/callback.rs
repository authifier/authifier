//! Handle the callback from the ID provider
//! GET /sso/authorize
use std::collections::HashMap;

use authifier::config::Claim;
use authifier::models::{Account, IdProvider};
use authifier::util::{normalise_email, secure_random_str};
use authifier::{Authifier, Error, Result};
use iso8601_timestamp::Timestamp;
use rocket::http::{Cookie, CookieJar};
use rocket::response::Redirect;
use rocket::time::Duration;
use rocket::State;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct LoginToken {
    // ID provider Id
    pub iss: String,
    // Account Id
    pub aud: String,
    // Expiry timestamp
    pub exp: Timestamp,
    // Login token value
    pub sub: String,
}

#[derive(Serialize, Deserialize, JsonSchema, FromForm)]
pub struct DataCallback {
    /// The authorization code generated by the authorization server.
    pub code: Option<String>,
    /// The access token to access the requested scope.
    pub access_token: Option<String>,
    /// ID Token value associated with the authenticated session.
    pub id_token: Option<String>,
}

/// # Handle the callback from the ID provider
///
/// Handle the callback from the ID provider.
#[openapi(tag = "SSO")]
#[get("/callback?<data..>")]
pub async fn callback(
    authifier: &State<Authifier>,
    data: DataCallback,
    cookies: &CookieJar<'_>,
) -> Result<Redirect> {
    // Retrieve encoding/decoding secret
    let secret = authifier.database.find_secret().await?;

    // Retrieve cookie provided during authorization
    let cookie = cookies.get("callback-id").map(Cookie::value);

    // Ensure presence and validate integrity
    let id: String = match cookie.map(|c| secret.validate_claims(c)).transpose() {
        Ok(value) => value.ok_or(Error::MissingCallback)?,
        Err(_) => {
            return Err(Error::InvalidCallback);
        }
    };

    // Retrieve associated callback
    let callback = authifier.database.find_callback(&id).await?;
    {
        authifier.database.delete_callback(&id).await?;
    }

    // Ensure given ID provider exists
    let id_provider = match authifier.config.sso.get(&*callback.idp_id).cloned() {
        Some(config) => IdProvider::try_from(config).map_err(|_| Error::InvalidIdpConfig)?,
        None => return Err(Error::InvalidIdpId),
    };

    // Ensure authorization code was provided
    let Some(code) = data.code.as_deref() else {
        return Err(Error::MissingAuthCode);
    };

    // Exchange authorization code for access token
    let (response, id_token) = id_provider
        .exchange_authorization_code(authifier, code, &id)
        .await?;

    let mut claims = HashMap::with_capacity(id_provider.claims.len());

    // Extract claims for ID token
    if let Some(id_token) = id_token {
        let values = id_provider.claims.iter().filter_map(|(claim, key)| {
            let value = id_token.get(key).cloned()?;

            Some((claim.to_owned(), value))
        });

        claims.extend(values);
    }

    // Extract claims for userinfo JWT
    if let Some(userinfo) = id_provider
        .fetch_userinfo(authifier, &response.access_token)
        .await?
    {
        let values = id_provider.claims.iter().filter_map(|(claim, key)| {
            let value = userinfo.get(key).cloned()?;

            Some((claim.to_owned(), value))
        });

        claims.extend(values);
    }

    // Ensure either one contained the identifier claim
    let Some(sub_id) = claims.get(&Claim::Id) else {
        return Err(Error::InvalidIdClaim);
    };

    let account = match authifier
        .database
        .find_account_by_sso_id(&callback.idp_id, &sub_id.to_string())
        .await?
    {
        // Account was previously logged in with through SSO
        Some(mut account) => {
            if let Some(email) = claims.get(&Claim::Email).and_then(|value| value.as_str()) {
                // Update email if present in claims
                account.email = email.to_owned();
                account.email_normalised = normalise_email(email.to_owned());
            }

            account
        }
        None => {
            // TODO: no email present in claims?
            let Some(email) = claims.get(&Claim::Email).and_then(|value| value.as_str()) else {
                todo!()
            };

            // Get a normalised representation of the user's email
            let email_normalised = normalise_email(email.to_owned());

            // Try to find an existing account
            if let Some(_account) = authifier
                .database
                .find_account_by_normalised_email(&email_normalised)
                .await?
            {
                // TODO: convert existing account to SSO?

                todo!()
            }

            // Create new account
            Account::from_claims(
                authifier,
                callback.idp_id.clone(),
                sub_id.to_owned(),
                email.to_owned(),
            )
            .await?
        }
    };

    let timestamp = Timestamp::now_utc().checked_add(Duration::seconds(60 * 2));

    // Generate login token
    let login_token = LoginToken {
        iss: callback.idp_id.clone(),
        aud: account.id.clone(),
        exp: timestamp.map(Into::into).expect("time overflow"),
        sub: secure_random_str(64),
    };

    // TODO: are we sure this will be overwritten?
    cookies.add(Cookie::build(("callback-id", String::new())));

    // TODO: URI encoding?
    Ok(Redirect::found(format!(
        "{}?redirect_uri={}",
        callback.redirect_uri,
        secret.sign_claims(&login_token),
    )))
}
