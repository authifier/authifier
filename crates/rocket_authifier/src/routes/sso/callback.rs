//! Handle the callback from the ID provider
//! GET /sso/authorize
use std::collections::HashMap;
use std::str::FromStr;

use authifier::config::Claim;
use authifier::models::Account;
use authifier::util::normalise_email;
use authifier::{Authifier, Error, Result};
use rocket::http::hyper::Uri;
use rocket::http::{Cookie, CookieJar, RawStr};
use rocket::response::Redirect;
use rocket::time::{Duration, OffsetDateTime};
use rocket::State;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct LoginToken {
    // ID provider Id
    pub iss: String,
    // Expiry timestamp
    pub exp: i64,
    // Login token value
    pub sub: String,

    pub username: Option<String>,
}

#[derive(Serialize, Deserialize, JsonSchema, FromForm)]
pub struct DataCallback {
    /// The authorization code generated by the authorization server.
    pub code: Option<String>,
    /// The access token to access the requested scope.
    pub access_token: Option<String>,
    /// ID Token value associated with the authenticated session.
    pub id_token: Option<String>,
}

/// # Handle the callback from the ID provider
///
/// Handle the callback from the ID provider.
#[openapi(tag = "SSO")]
#[get("/callback?<data..>")]
pub async fn callback(
    authifier: &State<Authifier>,
    data: DataCallback,
    cookies: &CookieJar<'_>,
) -> Result<Redirect> {
    // Verify callback state using stored cookie
    let id = cookies
        .get("callback-id")
        .map(Cookie::value)
        .ok_or(Error::MissingCallback)?;

    // Retrieve and immediately delete the stored callback state
    let callback = authifier.database.find_callback(id).await?;
    {
        authifier.database.delete_callback(id).await?;
    }

    // Validate the identity provider
    let id_provider = authifier
        .config
        .sso
        .get(&*callback.idp_id)
        .ok_or(Error::InvalidIdpId)?;

    let Some(code) = data.code.as_deref() else {
        return Err(Error::MissingAuthCode);
    };

    // Exchange authorization code for tokens
    let (response, id_token) = id_provider
        .exchange_authorization_code(authifier, &callback, code)
        .await?;

    let mut id_token = id_token.unwrap_or_default();

    // Fetch additional userinfo if possible
    if let Some(userinfo) = id_provider
        .fetch_userinfo(authifier, &response.access_token)
        .await?
    {
        id_token.extend(userinfo);
    }

    let claims: HashMap<_, _> = id_token
        .iter()
        .map(|(key, value)| match Claim::from_str(key) {
            Ok(claim) => (claim, value.to_owned()),
            Err(_) => unreachable!("infallible"),
        })
        .collect();

    eprintln!("{:?}", &claims);

    // Ensure that we received the mandatory subject ID
    let Some(sub_id) = claims.get(&Claim::Id) else {
        return Err(Error::InvalidIdClaim); // Required for account mapping
    };

    // Create new account or update existing one
    match authifier
        .database
        .find_account_by_sso_id(&callback.idp_id, &sub_id.to_string())
        .await?
    {
        Some(mut account) => {
            // Update email if provided in claims
            if let Some(email) = claims.get(&Claim::Email).and_then(|value| value.as_str()) {
                account.email = email.to_owned();
                account.email_normalised = normalise_email(email.to_owned());
            }
        }
        None => {
            let Some(email) = claims.get(&Claim::Email).and_then(|value| value.as_str()) else {
                // TODO: Should handle missing email case properly
                todo!()
            };

            let email_normalised = normalise_email(email.to_owned());

            // Check for existing account by email
            if let Some(mut account) = authifier
                .database
                .find_account_by_normalised_email(&email_normalised)
                .await?
            {
                account
                    .id_providers
                    .insert(callback.idp_id.clone(), sub_id.to_owned());
            } else {
                Account::from_claims(authifier, &callback.idp_id, sub_id, email).await?;
            }
        }
    };

    // Generate short-lived login token
    let exp = OffsetDateTime::now_utc()
        .checked_add(Duration::minutes(2))
        .expect("time overflow");

    let login_token = LoginToken {
        iss: callback.idp_id.clone(),
        sub: sub_id.to_string(),
        exp: exp.unix_timestamp(),

        username: claims
            .get(&Claim::Username)
            .and_then(|s| s.as_str().map(str::to_owned)),
    };

    eprintln!("{login_token:?}");

    if let Some(cookie) = cookies.get("callback-id").cloned() {
        cookies.remove(cookie);
    }

    let base_uri = callback
        .redirect_uri
        .parse::<Uri>()
        .map_err(|_| Error::InvalidRedirectUri)?;

    let secret = authifier.database.find_secret().await?;

    let claims = secret.sign_claims(&login_token);

    Ok(Redirect::found(format!(
        "{base_uri}?login_token={}",
        // Percent-encode the JWT to prevent injection
        RawStr::new(&claims).percent_encode()
    )))
}
